查询层

整个代码的入口在`cmd/bgdb.go`

Gremlin入口：

1 Gremlinquery 若未开启事务

2 GremlinTransaction 若开启事务

核心逻辑：`rungremintemplate`

主要调用gremlin.run方法



全面的`RunWithCtx`

核心执行逻辑`executor.run`





ServerHandler 字节的服务器接口 

```go
Prepare(ctx context.Context, m *gauss.Message)
列出了bytegragh提供的所有服务
```

ByteGraghServiceClient 客户端调用服务接口

BgdbHandler 服务器

```go
type BgdbHandler struct {
   conn      bgkv.Connector
   pointconn bgkv.Connector
  //用来连接操作bgkv的连接器
  
   pool      *bgdbutils.SharedPool
  //共享携程池？
  
   pcache    *querycache.PartMetasQueryCache
  //query内存池？
  
   cache     *bigcache.BigCache
  //github/allegro

   ctxBgPool *ants.Pool
  //高性能携程池，goroutine复用，限制携程数量
  
   locker    transaction.Locker

   psmQuotas               map[string]*PsmQuota
   handleAssistRateLimiter ratelimiter.RateLimiter

   graph distgraph.Graph
  //存储的图

   isBgkvV2          bool
   isMultiIDCV2Slave func() bool

   ddlManager *ddl.DDLManager
}
```



```go
type PartMetasQueryCache struct {
   ttl    time.Duration
   shards [shardNum]cache.Cache //内存片
  //cache有两种实现，lru和lfu两种算法
  //lru 最近最少使用
  //lfu 最不经常使用

   // cache hit ratio
   cacheHitCnt  counter.PerPCounter
   cacheMissCnt counter.PerPCounter
}
```

多个GQ与多个GS并行运行是如何体现的？



InsertEdge流程：

`handler.go/InsertEdge`

先处理是否Overload？

- 先检查goroutine是否overload（是否大于config规定的max携程数？）
- config里面是否允许写
- 检查服务是否有余量
- 对每个Request：
- - 检查边是否合法
  - lock2pc
  - planner生成插入计划
- 并行Execute计划



在gs侧：

入口：`handler/graph_database_service.h`

从InsertEdge进入

由于Gremlin是函数式语言，因此可以从左至右解析

首先用Lexer()







1. 两次pc取
2. context？
3. exec.run设计
